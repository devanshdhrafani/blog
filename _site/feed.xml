<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-15T21:38:43+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Devansh Dhrafani</title><subtitle>Musings of a Roboticist
</subtitle><author><name>Devansh Dhrafani</name><email>f20171569@hyderabad.bits-pilani.ac.in</email></author><entry><title type="html">Setup ROS2 in a Docker Container</title><link href="http://localhost:4000/2021/04/15/dockerros2.html" rel="alternate" type="text/html" title="Setup ROS2 in a Docker Container" /><published>2021-04-15T00:00:00+05:30</published><updated>2021-04-15T00:00:00+05:30</updated><id>http://localhost:4000/2021/04/15/dockerros2</id><content type="html" xml:base="http://localhost:4000/2021/04/15/dockerros2.html">&lt;h2 id=&quot;why-docker&quot;&gt;Why Docker?&lt;/h2&gt;

&lt;p&gt;If you have ever tried building a third party ROS package, you know the time and effort it takes to setup the required dependencies. Often times, the package you are trying to install will be compatible with only specific versions of its dependencies. Say for example you are using a deep learning framework like TensorFlow/PyTorch. These frameworks require specific version of CUDA packages to run correctly. If you already have an incompatible version of CUDA installed, your TensorFlow installation may throw errors. Downgrading/upgrading the CUDA version has its own set of associated problems. On top of this, if you are working on a collaborative project, the version of TensorFlow and CUDA that you have might not be the same as what your colleague is using. This may result in the classic problem of software development: “It works on my machine”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/dockerros2/worksonmymachine.png?style=centerme&quot; alt=&quot;It Works on My Machine&quot; class=&quot;image--xxl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is where Docker comes in. Docker is like a virtual machine, but smarter. A VM runs an entire OS within an OS, taking up precious computing resources. Docker is much smarter. A Docker VM, called a ‘Container’, only runs a stripped down version of an OS. This bare-bones version of any OS only has the minimum required packages to run whatever task you are trying to accomplish. Docker containers also utilize the full memory and processing power of your system, making them much faster than traditional VMs. The benefits of using Docker containers for software development are endless and require their own separate article to do proper justice. For now, I will explain how using Docker simplifies our ROS2 installation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/dockerros2/dockervsvm.png?style=centerme&quot; alt=&quot;Docker vs VM&quot; class=&quot;image--xxxl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Every ROS version requires a specific Ubuntu version to run. For example, ROS Melodic is made for Ubuntu 18.04. Installing Melodic on Ubuntu 20.04 will undoubtedly cause problems. The current Long-Term-Supported (LTS) version of ROS2 is called Foxy Fitzroy. ROS2 Foxy is made for Ubuntu 20.04. So for installing ROS2 on your system, you will need Ubuntu 20.04. But as Melodic is the current LTS for ROS1, there is a high chance that you, like me, are using Ubuntu 18.04. Even if you are using Ubuntu 20.04, there is a chance that you might have ROS1 Noetic installed on your system. In all these cases, installing ROS2 will cause numerous problems, be it due to incompatible OS version, or simply due to conflicts between ROS1 and ROS2 packages. To avoid this, we can install and run ROS2 in an Ubuntu 20.04 Docker container.&lt;/p&gt;

&lt;h2 id=&quot;docker-containers-images-and-dockerfiles&quot;&gt;Docker Containers, Images and Dockerfiles&lt;/h2&gt;

&lt;p&gt;The simplest way to understand Containers and Images is via an Object Oriented Programing (OOP) analogy. A Docker image is like a class and a Docker Container is an object (or instantiation) of the image. A &lt;strong&gt;Docker Image&lt;/strong&gt; contains everything needed to run a container: code, libraries, environment variables, configuration files, etc. It serves as a blueprint which can be used to create an instance, ie, a &lt;strong&gt;Docker Container&lt;/strong&gt;. Once a Docker Container is created, you can tinker with it as much as you like, and it won’t affect the image from which it was built.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/dockerros2/imagecontainerfile.png?style=centerme&quot; alt=&quot;Dockerfiles, Images and Containers&quot; class=&quot;image--xxxl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can find prebuilt Docker Images for many different applications on the DockerHub&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, which uses a GitHub like cloud solution where you can pull images to your local computer. These prebuilt images have relevant libraries, environment variables, etc. already setup so you can simply create a Container from the Image and get started on your work.&lt;/p&gt;

&lt;p&gt;If you can’t find a suitable image for your use case on DockerHub, you can create your own Docker Image using a Dockerfile. A &lt;strong&gt;Dockerfile&lt;/strong&gt; is a set of instructions to build a Docker Image. You can learn more about the syntax and standard practices of writing a Dockerfile from the documentation&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. For the purposes of this guide, I will explain the commands that I used as we go.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;The Open Source Robotics Foundation(OSRF) has hosted ROS Docker Images on the DockerHub. While having the knowledge of Dockerfiles and building your own images is helpful, if you are in a hurry, you can pull the ROS2 image from DockerHub &lt;a href=&quot;https://hub.docker.com/r/osrf/ros2/&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;building-the-ros2-image&quot;&gt;Building the ROS2 Image&lt;/h2&gt;

&lt;p&gt;ROS2 Foxy Fitzroy is made to run on Ubuntu 20.04. So in the first line, we download the Ubuntu 20.04 Docker Image:&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; ubuntu:20.04&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you don’t have the image locally, Docker is smart enough to pull it from the official Ubuntu Images on DockerHub.&lt;/p&gt;

&lt;p&gt;The instructions that follow are for the ROS2 installation on top of Ubuntu 20.04. My approach to this was modifying the existing set of instructions given in the ROS2 documentation&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;set-locale&quot;&gt;Set locale&lt;/h3&gt;

&lt;p&gt;This can be done easily in Docker Images using:&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ENV&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; LANG C.UTF-8&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ENV&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; LC_ALL C.UTF-8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The ENV command is used, as the name suggests, to set the environment variables.&lt;/p&gt;

&lt;h3 id=&quot;setup-sources&quot;&gt;Setup Sources&lt;/h3&gt;

&lt;p&gt;Next, we need to setup the sources so that the system knows where to look for ROS2 packages. The RUN command essentially lets us execute terminal commands.&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; curl gnupg2 lsb-release
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-sSL&lt;/span&gt; https://raw.githubusercontent.com/ros/rosdistro/master/ros.key  &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /usr/share/keyrings/ros-archive-keyring.gpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that there is no sudo before apt. This is because by default, you are already logged in as root in docker. The -y was added to bypass the prompt by apt, which asks the user if they want to continue the installation or not.&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deb [arch=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;dpkg &lt;span class=&quot;nt&quot;&gt;--print-architecture&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;lsb_release &lt;span class=&quot;nt&quot;&gt;-cs&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; main&quot;&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;tee&lt;/span&gt; /etc/apt/sources.list.d/ros2.list &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;install-ros2-packages&quot;&gt;Install ROS2 packages&lt;/h3&gt;

&lt;p&gt;After updating the existing packages, we are ready to install ROS2 foxy. This is as simple as:&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apt update
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DEBIAN_FRONTEND&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;noninteractive apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; ros-foxy-desktop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The ROS installation asks for configuration prompts in between the installation. Especially for selecting the timezone and keyboard language. Using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEBIAN_FRONTEND=noninteractive&lt;/code&gt; allows to bypass this step by letting the installer pick the defaults. And -y as before automatically switches answers to yes when prompted.&lt;/p&gt;

&lt;h3 id=&quot;setting-up-a-workspace&quot;&gt;Setting up a workspace&lt;/h3&gt;

&lt;p&gt;While the above steps are enough to build a Docker Image with ROS2, it’s nice to add the following lines for convenience. The first thing that you might end up doing after a ROS installation is setting up a workspace. While this is a fairly easy task, it’s always nice to automate even that, so you can get started right away.&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /root/dev_ws/src&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;git clone https://github.com/ros/ros_tutorials.git &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; foxy-devel
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /root/dev_ws&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above lines make a folder called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dev_ws&lt;/code&gt; which will serve as the colcon workspace. And also clone the ROS2 tutorials for beginners. The WORKDIR command, as the name suggests, changes the working directory of the terminal that the Docker Container is running in. Docker is smart enough that if such a directory doesn’t exist, it will make one without prompting the user.&lt;/p&gt;

&lt;p&gt;Finally, we install rosdep and colcon. Both are essential packages for ROS2. &lt;strong&gt;Rosdep&lt;/strong&gt; helps resolves errors associated with missing dependencies. &lt;strong&gt;Colcon&lt;/strong&gt; is the next iteration of catkin_make and other tools that were used for building packages in ROS1.&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;python3-rosdep &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;rosdep init
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;rosdep update
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;rosdep &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--from-path&lt;/span&gt; src &lt;span class=&quot;nt&quot;&gt;--rosdistro&lt;/span&gt; foxy &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;python3-colcon-common-extensions &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;entrypoint-for-ros2&quot;&gt;Entrypoint for ROS2&lt;/h3&gt;

&lt;p&gt;For using ROS commands in any new terminal, we need to source the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup.bash&lt;/code&gt; file. To avoid the hassle of sourcing the file in every terminal, we normally add a script to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; file. A similar thing can be done for Docker Containers.&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; ros2_entrypoint.sh /root/.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ENTRYPOINT&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;/root/ros2_entrypoint.sh&quot;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;bash&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The COPY command copies the entrypoint shell script that I wrote to the root of the Docker Container. This script will source the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup.bash&lt;/code&gt; file. The command ENTRYPOINT allows us to set the script which will run each time a container is started. Finally the CMD  command is used to set bash as the default executable when the container is first started.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This brings us to the end of this little guide. While they might seem tricky to setup, using Docker Containers for software development saves a lot of hassle in the longer run. It gives the developer a peace of mind, knowing that even if he/she messes up the OS, it won’t damage their own system, as the OS is running inside a Container. I hope this guide helped you understand and appreciate how simple it is to setup your own Docker Image/Container. You can check out the code for my Dockerfile. The Open Source Robotics Foundation also has their own ROS Docker Images&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, which are regularly updated on the DockerHub. If you want to save some time and are content with the default dependencies that the OSRF Docker Images have, you can always pull the image of your choice from DockerHub.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;image-sources&quot;&gt;Image Sources:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;It works on my computer comic&lt;/strong&gt; - &lt;a href=&quot;https://donthitsave.com/comic/2016/07/15/it-works-on-my-computer&quot; target=&quot;_blank&quot;&gt;Jeff Lofvers - Don’t Hit Save&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Docker Container &amp;amp; Traditional VM&lt;/strong&gt; - &lt;a href=&quot;https://codingthesmartway.com/docker-beginners-guide-part-1-images-containers/&quot; target=&quot;_blank&quot;&gt;Sebastian Eschweiler - Coding The Smart Way&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dockerfile, Image and Container&lt;/strong&gt; - &lt;a href=&quot;https://medium.com/swlh/understand-dockerfile-dd11746ed183&quot; target=&quot;_blank&quot;&gt;Rocky Chen - Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;DockerHub&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/develop/develop-images/dockerfile_best-practices/&quot; target=&quot;_blank&quot;&gt;Dockerfile best practices&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.ros.org/en/foxy/Installation/Ubuntu-Install-Debians.html&quot; target=&quot;_blank&quot;&gt;ROS2 Installation&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://hub.docker.com/r/osrf/ros2/&quot; target=&quot;_blank&quot;&gt;DockerHub - OSRF ROS2&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Devansh Dhrafani</name><email>f20171569@hyderabad.bits-pilani.ac.in</email></author><category term="ROS2" /><category term="Docker" /><summary type="html">If you have ever tried building a third party ROS package, you know the time and effort it takes to setup the required dependencies. Often times, the package you are trying to install will be compatible with only specific versions of its dependencies. Running your ROS Installation inside a Docker Container can help solve many of these problems.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://devanshdhrafani.github.io/blog/assets/images/dockerros2/imagecontainerfile.png" /><media:content medium="image" url="https://devanshdhrafani.github.io/blog/assets/images/dockerros2/imagecontainerfile.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">SLAM with MIT-Racecar (Gazebo)</title><link href="http://localhost:4000/2021/02/08/racecar1.html" rel="alternate" type="text/html" title="SLAM with MIT-Racecar (Gazebo)" /><published>2021-02-08T00:00:00+05:30</published><updated>2021-02-08T00:00:00+05:30</updated><id>http://localhost:4000/2021/02/08/racecar1</id><content type="html" xml:base="http://localhost:4000/2021/02/08/racecar1.html">&lt;p&gt;For a recent project, I had to map an environment using the &lt;strong&gt;MIT-Racecar&lt;/strong&gt; robot in Gazebo. This is a log of my progress implementing &lt;strong&gt;Simultaneous Localisation and Mapping (SLAM)&lt;/strong&gt; on the MIT-Racecar bot. I encountered some interesting problems, and learnt a few things while solving them. In this short post, I will summarise the steps that I used to solve the problems and get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gmapping&lt;/code&gt; to run on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;racecar_gazebo&lt;/code&gt; simulator.&lt;/p&gt;

&lt;p&gt;After cloning the &lt;strong&gt;racecar&lt;/strong&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and &lt;strong&gt;racecar_gazebo&lt;/strong&gt;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; packages to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/src&lt;/code&gt; directory and building them using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catkin_make&lt;/code&gt;, I launched the simulation using:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;roslaunch racecar-env racecar_tunnel.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course things never work at the first try. I encountered 2 errors which were fixed by installing the following dependencies:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/ackermann_msgs&quot; target=&quot;_blank&quot;&gt;ackermann_msgs&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/effort_controllers&quot; target=&quot;_blank&quot;&gt;effort_controllers&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now running the same environment launched Gazebo and spawned the racecar in the tunnel map.&lt;/p&gt;

&lt;p&gt;To map the environment, I used gmapping. After setting up the launch file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gmapping.launch&lt;/code&gt; and running it, rviz showed the warning: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;No map received&lt;/code&gt;. The terminal showed&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ WARN] [1612766930.932705394, 1106.617000000]: MessageFilter [target=odom ]: Dropped 100.00% of messages so far. Please turn the [ros.gmapping.message_filter] rosconsole logger to DEBUG for more information.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Clearly, there was some error with the odometry information. A quick&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rosrun tf view_frames
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;revealed that the there was no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;odom --&amp;gt; base_link&lt;/code&gt; transform that is necessary for gmapping to run properly. Refer &lt;strong&gt;REP 105&lt;/strong&gt;&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; for the convention.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/racecar1/frames1.png&quot; alt=&quot;TF&quot; class=&quot;border&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are 2 ways of fixing this error:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Using the &lt;strong&gt;static transform publisher&lt;/strong&gt;&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, a transformation can be created from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;odom --&amp;gt; base_link&lt;/code&gt;. This will work in the case that the robot is fixed with respect to the map. But as I wanted the racecar to explore and map the environment, this approach isn’t viable.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Dynamically publish&lt;/strong&gt; the relationships between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;odom&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base_link&lt;/code&gt; frame. Generally, this is done using inputs from on-board sensors like encoders and lidar to estimate the robot’s location w.r.t. the map.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Point 2 is the ideal approach. But as the robot is running in simulation, a clever shortcut can be used: Instead of using sensor readings, one can use the simulator(gazebo)’s information of the robot pose for odometry. A closer look at the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mit-racecar&lt;/code&gt; code revealed that that’s exactly what’s being done in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gazebo_odometry.py&lt;/code&gt; script located in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;racecar_gazebo&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;Executing&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rosnode info /gazebo_odometry_node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;revealed that this node is subscribing to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/gazebo/link_states&lt;/code&gt; topic which provides the robot pose information. It’s also publishing to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/tf&lt;/code&gt; topic, which is where the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map--&amp;gt;odom&lt;/code&gt; transform is being broadcast. This is in line with what we saw in tf tree above.&lt;/p&gt;

&lt;p&gt;So I made a slight modification to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gazebo_odometry.py&lt;/code&gt; to configure the tf tree for gmapping. After looking at the ROS wiki documentation for the &lt;strong&gt;slam_gmapping package&lt;/strong&gt;&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;, I found that for gmapping to run correctly, it needs an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;odom--&amp;gt;base_link--&amp;gt;laser&lt;/code&gt; transform. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gazebo_odometry.py&lt;/code&gt; node was written, (from what I understood), for navigation purposes. That’s why it transforms &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map--&amp;gt;odom&lt;/code&gt;, instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;odom--&amp;gt;base_link&lt;/code&gt;. So I simply changed the parent link to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;odom&lt;/code&gt; and child link to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base_link&lt;/code&gt; in the script and voila! We now have working SLAM!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/racecar1/gmapping.png&quot; alt=&quot;Gmapping&quot; class=&quot;border&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map--&amp;gt;odom&lt;/code&gt; transform is now provided by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/slam_gmapping&lt;/code&gt; node. We can see the same by looking again at the tf tree:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/racecar1/frames2.png&quot; alt=&quot;TF&quot; class=&quot;border&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Below is a scribd embed if you want to have a closer look at the final TF Tree.&lt;/p&gt;

&lt;iframe class=&quot;scribd_iframe_embed&quot; title=&quot;MIT-racecar gmapping TF&quot; src=&quot;https://www.scribd.com/embeds/493778944/content?start_page=1&amp;amp;view_mode=scroll&amp;amp;access_key=key-pGyvLCwYtc4KjXpIb50o&quot; data-auto-height=&quot;true&quot; data-aspect-ratio=&quot;2.342857142857143&quot; scrolling=&quot;no&quot; id=&quot;doc_88947&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script type=&quot;text/javascript&quot;&gt;(function() { var scribd = document.createElement(&quot;script&quot;); scribd.type = &quot;text/javascript&quot;; scribd.async = true; scribd.src = &quot;https://www.scribd.com/javascripts/embed_code/inject.js&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(scribd, s); })();&lt;/script&gt;

&lt;p&gt;Finally, I ran the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keyboard_teleop.py&lt;/code&gt; script using&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rosrun racecar_control keyboard_teleop.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to teleoperate the racecar. Once a good map is obtained, it can be saved using&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rosrun map_server map_saver &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; mymap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this, we come to the end of this post. The key takeaway from this post is that &lt;strong&gt;TF transforms are an extremely important&lt;/strong&gt; part of ROS. It is vital that a ROS Developer be comfortable with interpreting the TF tree. To any beginner ROS users, I would recommend to always run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tf view_frames&lt;/code&gt; node and take a look at the TF tree when implementing someone else’s package.&lt;/p&gt;

&lt;p&gt;Next I will be implementing the &lt;strong&gt;ROS Navigation Stack&lt;/strong&gt;&lt;sup id=&quot;fnref:6&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; on the mit-racecar robot. I will post here if I encounter any interesting problems.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/mit-racecar/racecar&quot; target=&quot;_blank&quot;&gt;racecar&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/mit-racecar/racecar&quot; target=&quot;_blank&quot;&gt;racecar_gazebo&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.ros.org/reps/rep-0105.html#relationship-between-frames&quot; target=&quot;_blank&quot;&gt;REP 105&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/tf#static_transform_publisher&quot; target=&quot;_blank&quot;&gt;static_transform_publisher&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/slam_gmapping&quot; target=&quot;_blank&quot;&gt;slam_gmapping&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/navigation&quot; target=&quot;_blank&quot;&gt;ROS Navigation Stack&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Devansh Dhrafani</name><email>f20171569@hyderabad.bits-pilani.ac.in</email></author><category term="ROS" /><category term="Mobile Robot" /><summary type="html">For a recent project, I had to map an environment using the MIT-Racecar robot in Gazebo. This is a log of my progress implementing Simultaneous Localisation and Mapping (SLAM) on the MIT-Racecar bot. I encountered some interesting problems, and learnt a few things while solving them. In this short post, I will summarise the steps that I used to solve the problems and get gmapping to run on the racecar_gazebo simulator.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://devanshdhrafani.github.io/blog/assets/images/racecar1/gmapping.png" /><media:content medium="image" url="https://devanshdhrafani.github.io/blog/assets/images/racecar1/gmapping.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Mobile Robot 1: URDF, Sensors, Gazebo and Rviz</title><link href="http://localhost:4000/2020/11/01/diffdrive.html" rel="alternate" type="text/html" title="Mobile Robot 1: URDF, Sensors, Gazebo and Rviz" /><published>2020-11-01T00:00:00+05:30</published><updated>2020-11-01T00:00:00+05:30</updated><id>http://localhost:4000/2020/11/01/diffdrive</id><content type="html" xml:base="http://localhost:4000/2020/11/01/diffdrive.html">&lt;p&gt;Software simulation in ROS can help you learn about how to make robots “think.” It is a long way to go from a line following bot to a self-driving car!  This makes software development one of the hardest fields to explore for enthusiasts. This is where the Robot Operating System (ROS) comes in. The highly modular nature of ROS facilitates a developer to focus on their domain and use one of the many open-source ROS packages to fill in the gaps.&lt;/p&gt;

&lt;p&gt;In this project, I developed a ROS package that implements SLAM and Autonomous Navigation on a custom 2 wheeled Differential Drive robot in Gazebo. Throughout the development of this project, I learnt several new ROS concepts which are essential to understand for any beginner. In these posts, I will summarise the steps that I followed (along with relevant links) and hopefully, by the end, you would have learnt something new.&lt;/p&gt;

&lt;p&gt;Bur first, let’s watch the final result:&lt;/p&gt;
&lt;div&gt;&lt;div class=&quot;extensions extensions--video&quot;&gt;
  &lt;iframe src=&quot;https://www.youtube.com/embed/jbd2p1llsqA?rel=0&amp;amp;showinfo=0&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;info&quot;&gt;To follow along, I would suggest that you install the ROS package using the instructions in the GitHub Repository&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. You can find the same &lt;a href=&quot;https://github.com/devanshdhrafani/diff_drive_bot&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;urdf-and-sensors&quot;&gt;URDF and Sensors&lt;/h2&gt;

&lt;p&gt;We will be using Gazebo as a simulation environment for our purposes, so, we need to describe the robot model in a way that Gazebo can understand it. The &lt;strong&gt;Unified Robotic Description Format (URDF)&lt;/strong&gt; comes to our aid here. URDF describes all the physical properties of a robot, like its basic blocks (links), how links move relative to one another (joints), inertial properties of the links, visual appearance in Gazebo, collision properties, etc.&lt;/p&gt;

&lt;p&gt;Apart from that, as we are working in a simulation environment, we will need the robot to get sensor data like LIDAR point clouds, camera feed, etc. We also need a way to move the robot in Gazebo. All these are done using &lt;strong&gt;Gazebo plugins&lt;/strong&gt;.&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;So now, let’s look at the URDF for our robot. There are 4 files located in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/urdf/&lt;/code&gt; folder:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;mybot.xacro&lt;/li&gt;
  &lt;li&gt;materials.xacro&lt;/li&gt;
  &lt;li&gt;mybot.gazebo&lt;/li&gt;
  &lt;li&gt;macros.xacro&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URDF is written in XML. And as you can see, it gets a bit complicated when dealing with many links and joints. To avoid rewriting certain blocks of code, we can use &lt;strong&gt;Xacro&lt;/strong&gt;. Xacro effectively gives us shortcuts to help reduce the overall size of the URDF file which makes it easier to read and maintain. I followed the &lt;strong&gt;ROS Wiki URDF Tutorials&lt;/strong&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; to learn about URDF and Xacros.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mybot.xacro&lt;/code&gt; file is our main URDF. It specifies all the joints, links, sensors. You can see that we are importing the other files using:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;xacro:include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;filename=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find diff_drive_bot)/urdf/mybot.gazebo&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;xacro:include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;filename=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find diff_drive_bot)/urdf/materials.xacro&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;xacro:include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;filename=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find diff_drive_bot)/urdf/macros.xacro&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Let’s look at a code snippet from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mybot.xacro&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'chassis'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;pose&amp;gt;&lt;/span&gt;0 0 0.1 0 0 0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/pose&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;inertial&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;mass&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;15.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;origin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xyz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.0 0 0.1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rpy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; 0 0 0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;inertia&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;ixx=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ixy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ixz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;iyy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;iyz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;izz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/inertial&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;collision&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'collision'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;geometry&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;box&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.4 .2 .1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/geometry&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/collision&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;visual&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'chassis_visual'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;origin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xyz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0 0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rpy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; 0 0 0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;geometry&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;box&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;size=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.4 .2 .1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/geometry&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/visual&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, we are defining a link chassis and specifying its visual, inertial and collision properties. 
To describe the joints between 2 links, we use:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;joint&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;continuous&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;left_wheel_hinge&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;origin&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xyz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0.15 0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rpy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0 0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;child&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;link=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;left_wheel&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;parent&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;link=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;chassis&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;axis&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xyz=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 1 0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rpy=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0 0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;limit&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;effort=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;velocity=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1000&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;joint_properties&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;damping=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;friction=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/joint&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, the joint between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;left_wheel&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chassis&lt;/code&gt; is called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;left_wheel_hinge&lt;/code&gt; and is a &lt;strong&gt;continuous&lt;/strong&gt; type hinge. Meaning it rotates about its axis with no limits. Learn more about all 6 types of URDF joints here.&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mybot.gazebo&lt;/code&gt; file contains the gazebo plugins for the differential drive motion and sensors. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;materials.xacro&lt;/code&gt; contains all the colour RGB values that we use in mybot.xacro and mybot.gazebo. Finally, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;macros.xacro&lt;/code&gt; contains all the macros for mathematical equations used to define the robot.  It’s not being used in this case because we have fixed all the values. But if you were to change the dimensions of your robot, you can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;macros.xacro&lt;/code&gt; file to avoid calculating the other related dimensions.&lt;/p&gt;

&lt;p&gt;Again, to learn how to write URDF and use Xacro, the ROS Wiki tutorial&lt;sup id=&quot;fnref:2:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; series is a good place to start.&lt;/p&gt;

&lt;h2 id=&quot;gazebo-and-rviz&quot;&gt;Gazebo and Rviz&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Gazebo&lt;/strong&gt; is an open-source 3D robotics simulator. This means that it is essentially a replacement for the “&lt;strong&gt;Real World&lt;/strong&gt;”. Developers can test their algorithms on Gazebo first, iron out the bugs and then finally build and implement on a real robot. &lt;strong&gt;Rviz&lt;/strong&gt; stands for &lt;strong&gt;ROS visualization&lt;/strong&gt;. At any instant, several ROS nodes are publishing and subscribing messages on various topics. Some of these messages are difficult to understand by just reading the values. Rviz helps us visualize the message data. E.g., LIDAR point clouds are displayed as dots in Rviz, making it much more intuitive than seeing thousands of numbers in an array.&lt;/p&gt;

&lt;p&gt;Let’s spawn our robot in Gazebo:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;roslaunch diff_drive_bot gazebo.launch 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;strong&gt;ROS launch&lt;/strong&gt;&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gazebo.launch&lt;/code&gt; starts up the ROS core, Gazebo, and spawns our robot in an empty world with the House model as the robot’s environment.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/diffdrive/gazebo.png&quot; alt=&quot;Gazebo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see that LIDAR’s laser bouncing off on the walls and objects of the environment. 
Now let’s start Rviz:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;roslaunch diff_drive_bot rviz.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This launch file sets the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;robot_description&lt;/code&gt; parameter to our robot URDF and publishes the &lt;strong&gt;joint and robot states&lt;/strong&gt;. These are essential to publish because otherwise, Rviz won’t know how the robot links transform.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/images/diffdrive/rviz.png&quot; alt=&quot;Rviz&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see in Rviz that the LIDAR data published on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scan&lt;/code&gt; topic is visualised as red dots, showing the obstacles and walls in the robot’s path.&lt;/p&gt;

&lt;h2 id=&quot;teleoperation&quot;&gt;Teleoperation&lt;/h2&gt;

&lt;p&gt;Now that we setup the URDF, Sensors and watched the robot in Gazebo and the sensor data in Rviz, its time to move the robot! For the purpose of this demonstration, I modified the turtlebot3 keyboard teleoperation node to suit our needs. To use that, execute:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;rosrun diff_drive_bot keyboard_teleop.py 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You would now be able to move the robot around in Gazebo. Observe how the Rviz laser scan point cloud also changes as the robot moves around in the environment.&lt;/p&gt;

&lt;p&gt;With that, this little tutorial/guide is over. I hope that you learnt something new about URDF, Sensors and how to visualise them in Gazebo and Rviz. If you have any questions/suggestions, feel free to drop them below. In the next post, I will share how I implemented SLAM and the ROS Navigation stack on the above robot.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/devanshdhrafani/diff_drive_bot&quot; target=&quot;_blank&quot;&gt;GitHub Repo&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://gazebosim.org/tutorials?tut=ros_gzplugins&quot; target=&quot;_blank&quot;&gt;Gazebo Plugins&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/urdf/Tutorials&quot; target=&quot;_blank&quot;&gt;URDF Tutorials&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:2:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/urdf/XML/joint&quot; target=&quot;_blank&quot;&gt;Types of URDF Joints&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://wiki.ros.org/roslaunch&quot; target=&quot;_blank&quot;&gt;ROS Launch Files&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Devansh Dhrafani</name><email>f20171569@hyderabad.bits-pilani.ac.in</email></author><category term="ROS" /><category term="Mobile Robot" /><summary type="html">I developed a ROS package that implements SLAM and Autonomous Navigation on a custom 2 wheeled Differential Drive robot in Gazebo. Throughout the development of this project, I learnt several new ROS concepts which are essential to understand for any beginner. This post summarises the steps that I followed with relevant links for learning the same.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://devanshdhrafani.github.io/blog/assets/images/diffdrive/gazebo.png" /><media:content medium="image" url="https://devanshdhrafani.github.io/blog/assets/images/diffdrive/gazebo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>